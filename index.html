<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Computer-Simulated Rigidbody Dynamics</title>

    <link rel="stylesheet" href="https://cdn.simplecss.org/simple.css">
    <link rel="stylesheet" type="text/css" href="style.css">

    <!-- Linking to the main p5.js library, which allows your code to use all 
       p5 functions. Using this version while developing your code allows p5 
       to provide more Friendly Error Messages if you mess something up...-->
    <script src="libraries/p5.js"></script>

    <!-- Once your project is working completely, you can comment out the link
       to p5.js above, and instead link to this minified version. The minified
       version takes less space, and turns off Friendly Error Messages. This 
       increases the speed of your program quite dramatically in some cases.-->
    <!-- <script src="libraries/p5.min.js"></script> -->

    <script src="libraries/p5.sound.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/styles/github-dark.min.css"/>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    

    <script>hljs.highlightAll();</script>
  </head>

  <body>
    <script src="implictEulerDemo.js"></script>
    <script src="forceInteractionDemo.js"></script>
    <script src="collisionSolverDemo.js"></script>
    <script type="module" src="poolDemo.js"></script>
    <script type="module" src="physicsDemo.js"></script>

    <header>
      <h1>Computer-Simulated Rigidbody Dynamics</h1>
    </header>
    
    <main>
      <section>
      
      <p>
        <b>Focus Question:</b> <br>
        How do computer simulations simulate the motion and interaction of rigid bodies in two dimensions?
        How do forces, kinematics, energy, and momentum influence the behavior of these bodies?
      </p>

      <p>
        <b>Physics Simulations</b> <br>
        In today’s world, we are surrounded by computers and technology. These computers can perform a multitude 
        of different tasks, some of which include connecting people across the world, displaying movies, managing 
        financial transactions, and even controlling complex machinery. One of the common applications of the 
        modern computer is its ability to simulate the real world; whether it's sending a rocket to the moon or 
        playing a first-person shooter video game, physics simulations play a crucial role. Physics simulations 
        allow us to predict real-world events, saving money and resources that would otherwise be necessary. In 
        my self-directed study, I plan to explore a specific area of computer-simulated physics: rigid body dynamics. 
        Rigid body dynamics is, by definition, the behavior of bodies as they move and interact with each other 
        and their environment.
      </p>

      <p>
        <b>What is a rigid body?</b> <br>
        A rigid body is an idealized physical object that does not deform under external forces, maintaining its 
        shape, size, and internal structure. While no real-world object is perfectly rigid, simulating a rigid body 
        requires much less computation power and simplifies the complexity of a true-to-world simulation. In the 
        simulations I will be observing and creating, I will assume that every physical object is a rigid body.
      </p>

      <p>
        <b>How might you create a simulation using a computer?</b> <br>
        A computer takes an input, and using the given instructions, it returns an output. Unfortunately, computers 
        cannot understand human languages such as English or French. Instructions given to computers must be in binary. 
        Binary is a system of information encoding using bits; each bit represents a state, either 1 (on) or 0 (off). 
        Over the years, engineers have been able to improve the process of writing computer code. Instead of having to 
        manually write 0s and 1s, we can now write code in more human-like languages. The code is then translated or 
        compiled into machine code (binary). There are hundreds of coding languages one can choose from, I will be 
        using a mix of javascript and sudo-code (a mix of English and code).
      </p>
    </section>   

      <p>
        <b>Euler Integration</b> <br>
        The most popular method for integrating force into the other equations for motion is the Implicit Euler Method. 
        This method uses numerical integration to find the solution for the next step in time. As opposed to using an 
        analytical approach, a numerical approach saves computation time but comes with inherent error. The Implicit 
        Euler Method is more accurate than the Explicit Euler Method, which is why most commercial applications of 
        physics simulations use the Implicit Method, such as Unity (a popular game development engine). The first step 
        in the Implicit Euler method is to take the current velocity and add to it the acceleration multiplied by the 
        delta time. \( \vec{v}_{n+1} = \vec{v}_n + \vec{a} \cdot \Delta t \) To find the new position we take the new 
        velocity, multiply by the delta time, and add it to the current position. \( \vec{d}_{n+1} = \vec{d}_n + \vec{v}_{n+1} \cdot \Delta t \) The method becomes more accurate as \( \Delta t \) approaches 0. In an ideal world, we could 
        simulate thousands of times every second to receive the most accurate results possible, unfortunately, this is 
        not possible in real life and we will have to settle with 60 simulation steps per second.
      </p>

      <p>
        <b>Comparing the kinematic equations to the Semi-Implicit Euler Method</b> <br>
        As I mentioned before in the section on Euler Integration there will be errors when using any of the various numerical integration techniques (some more than others). 
        Using the kinematic equations and comparing the results to the Semi-Implicit Euler method, 
        we find that when simulating at low delta times we end up with very impressive results. 
      </p>
      
      
      <div id="sketch-holder"></div>
      

      <p>
        <b>Adding in forces <br></b>
        When using numerical integration to solve for the motion of a rigid body the only parameters that we care about are the forces acting on our object and the mass of the object. 
        Using both the mass and the force we can solve for the acceleration and then use the aforementioned methods to solve for the other properties of motion. 
        $$\vec{F} = m \vec{a} \quad \quad \vec{a} = \frac{\vec{F}}{m}$$ Knowing this, we now have everything needed to work out what will happen at every step of our simulation.

        $$\vec{F} = \vec{F_g} + \vec{F_a} + \vec{F_N} + \vec{F_f}$$
        $$\vec{a} = \frac{\vec{F}}{m}$$

        $$\vec{v}_{n+1} = \vec{v}_n + \vec{a} \cdot \Delta t$$
        $$\vec{d}_{n+1} = \vec{d}_n + \vec{v}_{n+1} \cdot \Delta t$$


      </p>
      <figure>
        <div id="force-interaction-holder"></div>
      </figure>
      
    <p> <b>Impulses and Collisions</b> <br>
      Up to this point, we have some code that allows us to create a rigid body, and using the Implicit Euler Method we can move it around and apply gravity. 

      <pre style="width: 100%;">
        <code class="language-javascript">
// I'm using a js library for the vectors, called p5js
class Simulation{
  constructor(gravityStrength = 9.8) {
    // This array contains all the rigidbodies in the simulation
    this.rigidbodies = []; 

    // This is the strength of the gravity in the simulation
    this.gravityStrength = gravityStrength; 
  }

  addRigidbody(rigidbody) {
    // This function adds a rigidbody "object" to the simulation
    this.rigidbodies.push(rigidbody);
  }

  stepSimulation(dt) {
    // This function steps the simulation forward by dt seconds
    // It applies gravity to all the rigidbodies and then steps them forward in time

    for(let i = 0; i < this.rigidbodies.length; i++) {
      let rb = this.rigidbodies[i];
      rb.applyForce(this.p.createVector(0, this.gravityStrength * rb.mass));
      rb.stepSimulation(dt);
    } 
  }
}

class Rigidbody {
  constructor(mass, position, velocity, radius) {
    this.mass = mass;
    this.position = position;
    this.velocity = velocity;
    this.acceleration = 0; 
    this.radius = radius;
  }

  stepSimulation(dt) {
    // This function steps the rigidbody forward by dt seconds
    this.velocity.add(p5.Vector.mult(this.acceleration, dt)); // Implicit Euler Method
    this.position.add(p5.Vector.mult(this.velocity, dt)); // Implicit Euler Method

    this.acceleration.mult(0); // Reset the acceleration every step
  }

  applyForce(force) {
    // This function applies a force to the rigidbody in Newtons
    this.acceleration.add(p5.Vector.div(force, this.mass));
  }
}
    </code></pre> 

    As of now, the rigid bodies are isolated from their environment. This means they cannot interact with other rigid bodies or any external forces or constraints. 
    To create a more realistic simulation, it's necessary to allow interactions between rigid bodies and their environment. This leads us to our next step for the simulation, collisions. 
    To create a collision in a physics simulation you need to know if two rigid bodies are colliding, each rigid body’s momentum, and the normal vector between the two during the collision.

    <img src="images/Collision_response_rigid_impulse.png" alt="Two polygon rigid bodies colliding with each other with vector drawings displaying relavant information about the collision" class="center">

    For simplicity let’s use circles for the rigid bodies, as they are by far the most simple to use when it comes to collision detection and resolution. 
    The algorithm for detecting a collision is fairly simple. You loop through each pair of rigid bodies in the simulation and check if the distance between them is less than the sum of their radii. 
    If that is the case then the rigid bodies are overlapping.

    $$ \sqrt{(b_{1x} + b_{2x})^2 + (b_{1y} + b_{2y})^2} \leq (r_1 + r_2) $$

    Once we determine that two bodies are colliding we can resolve that collision. To resolve the collision, we need to use our knowledge of the classical laws for momentum.

    $$ \vec{P}_{tot} = \vec{P}'_{tot}, \quad n = \text{number of bodies} \rightarrow \vec{P}_{tot} = \sum_{i=1}^{n} \vec{P}_i \text{ and } \vec{P} = m \vec{v} $$
    These laws are the foundation for a popular collision resolution method called the Impulse Method. 

    This method involves directly modifying the velocities of objects using an impulse along the collision normal. 
    The Impulse Method uses the coefficient of restitution (e) to determine the overall momentum conservation of the system, with 1 being no momentum lost and 0 being no momentum conserved. 
    The derivation for this equation is complicated and beyond the scope of this SDS, however here is the equation taken from this <a target="_blank" rel="noopener noreferrer" href="https://research.ncl.ac.uk/game/mastersdegree/gametechnologies/physicstutorials/5collisionresponse/Physics%20-%20Collision%20Response.pdf">research paper</a> (ignoring the angular components):
    $$ \vec{v}_r = (\vec{v}_1 - \vec{v}_2) \rightarrow J = \frac{-(1 + e) \vec{v}_r \cdot \hat{n}}{\frac{1}{m_1} + \frac{1}{m_2}} $$

    <b>Collision Resolution Code</b> <br>
      <pre style="width: 100%;">
        <code class="language-javascript">
class CollisionSolver{
    constructor(simulation) {
        this.simulation = simulation;
    }

    resolveCollisions() {
        // Resolve all collisions (circle to circle)

        for (let i = 0; i < this.simulation.rigidbodies.length; i++) {
            for (let j = i + 1; j < this.simulation.rigidbodies.length; j++) {
                let rb1 = this.simulation.rigidbodies[i];
                let rb2 = this.simulation.rigidbodies[j];

                let distance = p5.Vector.sub(rb1.position, rb2.position).mag();

                if (distance < rb1.radius + rb2.radius) {
                    // They are colliding
                    let normal = p5.Vector.sub(rb1.position, rb2.position).normalize(); // Normal vector pointing from rb2 to rb1
                    let relativeVelocity = p5.Vector.sub(rb1.velocity, rb2.velocity); // Relative velocity of rb1 to rb2

                    const collisionOfRestitution = 1; // Perfectly elastic collision
                    let impulse = p5.Vector.mult(normal, p5.Vector.dot(normal, relativeVelocity) * (1 + collisionOfRestitution) / (1 / rb1.mass + 1 / rb2.mass));

                    rb1.velocity.sub(p5.Vector.div(impulse, rb1.mass)); // Subtract impulse from velocity of the first object
                    rb2.velocity.add(p5.Vector.div(impulse, rb2.mass)); // Add impulse to velocity of the second object

                    // Move the objects out of each other
                    let overlap = (rb1.radius + rb2.radius) - distance;
                    let correction = p5.Vector.mult(normal, overlap / (1 / rb1.mass + 1 / rb2.mass));

                    rb1.position.add(p5.Vector.div(correction, rb1.mass));
                    rb2.position.sub(p5.Vector.div(correction, rb2.mass));
                }
            }
        }
    }
}
        </code>
      </pre>

      <b>Energy Calculation Code</b> <br>
      <pre style="width: 100%;">
        <code class="language-javascript"> 
// Calculate the total energy and momentum of the simulation
// Run in the stepSimulation() function in the Simulation class
let totalSimulationEnergy = 0;
let totalSimulationMomentum = 0;

for(let i = 0; i < this.rigidbodies.length; i++) {
  let rb = this.rigidbodies[i];
  totalSimulationEnergy += (0.5 * rb.mass * rb.velocity.magSq()) + (this.gravityStrength * rb.mass * -(rb.position.y - this.p.height));
  totalSimulationMomentum += rb.velocity.mag() * rb.mass;
}
        </code>
      </pre>

      <div id="collision-solver-holder"></div>
    </p>

    <p> <b>Full Physics Engine</b> <br>
      Using the above principles as well as some new algorithms, I have created a 2D physics engine that works with circles and any convex polygon. 
      The physics engine also incorporates the angular component of the rigid bodies, allowing for rotation and a more accurate simulation. 
      The engine also supports compound bodies linked with custom offsets from the center of mass. 
      Some notable algorithms and formulae I used include the point segment distance formula, the separating axis theorem, 
      the axis-aligned bounding box (AABB) collision detection algorithm, the line-to-line intersection formula, 
      and the point-polygon intersection algorithm. The full engine code and its documentation are available on my <a target="_blank" rel="noopener noreferrer" href="https://commandmaster.github.io/PhysEngine2D">GitHub</a>

      <div id="full-engine-holder"></div>

    <br>
    <b>Pool Using The Complete Engine</b> <br>
    Use the Spacebar to shoot the cue ball toward the mouse pointer. 
    The cue ball will collide with the other balls and the walls of the pool table.
      <div id="pool-demo-holder"></div>
    </p>    

    <p>
      <b>Conclusion</b> <br>
      The study of rigid body dynamics is a very interesting field of physics. The principles of kinematics, forces, energy, and momentum are crucial to understanding the behavior and the accurate prediction of rigid bodies in a computer simulation. 
      The Implicit Euler Method is a great mix of performance and accuracy, allowing for quite accurate predictions of motion. 
      The creation of a physics engine is no easy task, requiring a well-versed understanding of both physics and mathematics. 
      The engine I have created is capable of simulating the motion and interaction of rigid bodies in two dimensions, providing a realistic representation of a physical system (In 2D). 
      I have learned a great deal about physics simulations and computer programming through this self-directed study, and, in the future, I look forward to exploring more advanced topics such as 3D simulations.
    </p>

    <p>
      <b>Sources</b> <br>
      Baraff, D. (n.d.). Physics: Collision response. Newcastle University. https://research.ncl.ac.uk/game/mastersdegree/gametechnologies/physicstutorials/5collisionresponse/Physics%20-%20Collision%20Response.pdf <br> <br>

      Bittle, W. (2010, January 1). SAT (Separating Axis Theorem). dyn4j. https://dyn4j.org/2010/01/sat <br> <br>

      Edgar Programmator. (2023, August 31). Find the intersection of two line segments in 2D (Easy Method) [Video]. YouTube. https://www.youtube.com/watch?v=bvlIYX9cgls <br> <br>

      Engineering Made Easy. (2019, February 9). Numerical Analysis - Backward Euler Method [Video]. YouTube. https://www.youtube.com/watch?v=cdUpAuGTIfE <br> <br>

      Integration Basics | Gaffer on Games. (2004, June 1). Gaffer on Games. https://gafferongames.com/post/integration_basics/ <br> <br>

      Souto, N. (2015, January 22). Video Game Physics Tutorial - Part I: An Introduction to Rigid Body Dynamics. Toptal Engineering Blog. https://www.toptal.com/game/video-game-physics-part-i-an-introduction-to-rigid-body-dynamics <br> <br>

      Two-Bit Coding. (2022, August 6). Contact points (Polygon/Polygon)- Let’s make a physics engine [20] [Video]. YouTube. https://www.youtube.com/watch?v=5gDC1GU3Ivg <br> <br>


    </p>

    </main>

    <footer>
      <p>
        &copy; 2024 Computer-Simulated Rigidbody Dynamics <br>
        Bennett Friesen <br>
        <a target="_blank" rel="noopener noreferrer" href="https://github.com/commandmaster/Physics-30-SDS">Code (Github Repo)</a> <br>
      </p>
    </footer>

  </body>
</html>
